# UDP 数据发送功能使用指南

## 功能概述

UDP上位机程序现已支持**双向通信**：
- ✅ **接收功能**：接收图像、日志等数据（原有功能）
- ✅ **发送功能**：发送自定义格式的数据帧（新增功能）

## 快速开始

### 1. 启动程序

```bash
python src/udp_gui.py
```

### 2. 基本配置

进入"发送"标签页，配置以下参数：

#### 发送配置页
- **目标IP**：接收设备的IP地址（例如：192.168.1.100）
- **目标端口**：接收设备的UDP端口（默认：8080）
- **帧头**：十六进制帧头（例如：AA55）
- **帧尾**：十六进制帧尾（例如：0D0A）
- **定时发送间隔**：自动发送的时间间隔（0.1-60秒）

点击"连接"按钮建立连接。

### 3. 编辑数据

切换到"数据编辑"页：

#### Hex模式
- 输入十六进制数据，空格分隔
- 示例：`AA 55 01 02 03 04 0D 0A`

#### 文本模式  
- 输入普通文本，自动转换为UTF-8
- 示例：`Hello, STM32!`

### 4. 发送数据

- **单次发送**：点击"单次发送"按钮
- **定时发送**：点击"启动定时发送"按钮（按配置的间隔自动发送）
- **停止发送**：点击"停止定时发送"按钮

### 5. 查看历史

切换到"发送历史"页查看已发送的数据包记录。

## 使用场景

### 场景1：发送控制指令

```
目标：向STM32发送控制命令

配置：
- 目标IP: 192.168.1.100
- 目标端口: 8080
- 帧头: AA55
- 帧尾: 0D0A
- 数据模式: Hex

发送内容（Hex模式）：
01 01      # 命令ID=1, 参数=1（开启电机）
01 00      # 命令ID=1, 参数=0（关闭电机）
02 64      # 命令ID=2, 参数=100（设置速度）

实际发送的数据帧：
AA55 0101 0D0A  # 完整帧格式
```

### 场景2：发送文本消息

```
目标：向设备发送调试信息

配置：
- 帧头: BB66
- 帧尾: 0D0A
- 数据模式: Text

发送内容（Text模式）：
STATUS:OK

实际发送的数据帧：
BB66 535441545553:4F4B 0D0A  # 帧头 + "STATUS:OK" + 帧尾
```

### 场景3：周期发送心跳包

```
目标：定时发送心跳包保持连接

配置：
- 帧头: AABB
- 帧尾: CCDD
- 定时间隔: 1.0秒
- 数据模式: Hex

发送内容：
FF

启动定时发送后，每秒自动发送：
AABB FF CCDD
```

### 场景4：发送参数配置

```
目标：向STM32发送PID参数

配置：
- 帧头: F0F0
- 帧尾: 0F0F
- 数据模式: Hex

发送内容（假设参数为uint16小端序）：
01 6400 3200 1900
# 类型=1, Kp=100(0x64), Ki=50(0x32), Kd=25(0x19)

实际发送：
F0F0 01640032001900 0F0F
```

## 高级功能

### 自定义帧格式

发送的数据帧格式为：
```
[帧头] + [数据内容] + [帧尾]
```

- **帧头/帧尾**：可选，留空则不添加
- **数据内容**：根据选择的模式（Hex/Text）编码
- **总长度**：界面会实时显示数据长度和总长度

### 数据编辑技巧

#### Hex模式
```
✅ 正确格式：
AA 55 01 02 03 04
AA55 01020304
AA55 
01020304

❌ 错误格式：
0xAA 0x55  # 不要加0x前缀
G1 H2      # 只能使用0-9, A-F
```

#### Text模式
```
✅ 支持的内容：
英文文本：Hello World
中文文本：你好世界（自动UTF-8编码）
特殊字符：@#$%^&*
多行文本（会保留换行符）
```

### 发送统计

- 发送历史记录最多保存100条
- 显示时间戳、数据（Hex）、说明
- 可手动清空历史记录
- 实时显示已发送包数

## 测试验证

### 方法1：使用测试脚本

```bash
# 终端1：启动测试接收器
python test_send.py

# 终端2：启动GUI
python src/udp_gui.py

# 在GUI中配置并发送数据，观察test_send.py的输出
```

### 方法2：使用Wireshark

1. 启动Wireshark抓包
2. 过滤器：`udp.port == 8080`
3. 在GUI中发送数据
4. 在Wireshark中验证数据包内容

### 方法3：回环测试

```
配置接收：
- 绑定IP: 127.0.0.1
- 端口: 8080
- 启动监听

配置发送：
- 目标IP: 127.0.0.1
- 目标端口: 8080
- 连接并发送

在"原始数据监视器"中查看接收到的数据
```

## 与STM32通信示例

### STM32接收端代码

```c
// UDP接收回调函数
void UDP_RecvCallback(uint8_t *data, uint16_t len)
{
    // 验证帧头
    if (len < 4 || data[0] != 0xAA || data[1] != 0x55) {
        return;  // 帧头错误
    }
    
    // 验证帧尾
    if (data[len-2] != 0x0D || data[len-1] != 0x0A) {
        return;  // 帧尾错误
    }
    
    // 提取数据（去除帧头帧尾）
    uint8_t *payload = data + 2;
    uint16_t payload_len = len - 4;
    
    // 解析命令
    uint8_t cmd = payload[0];
    uint8_t param = payload[1];
    
    switch(cmd) {
        case 0x01:  // 电机控制
            if (param == 0x01) {
                Motor_Enable();
            } else {
                Motor_Disable();
            }
            break;
        
        case 0x02:  // 设置速度
            Motor_SetSpeed(param);
            break;
        
        default:
            break;
    }
}
```

### 上位机发送配置

```
帧头: AA55
帧尾: 0D0A
模式: Hex

发送示例：
01 01  → 启动电机
01 00  → 停止电机
02 64  → 设置速度为100
```

## 常见问题

### Q1: 点击"连接"无反应？
- 检查目标IP地址格式是否正确（192.168.1.100）
- 检查端口号是否在有效范围（1-65535）
- 查看输出窗口的错误信息

### Q2: 发送失败？
- 确认已点击"连接"按钮
- 检查目标设备是否在线
- 检查防火墙设置
- 使用test_send.py验证网络连通性

### Q3: Hex格式错误？
- 只能使用0-9和A-F（大小写均可）
- 空格可选，用于分隔
- 不要添加0x前缀
- 必须是偶数个字符（两个字符表示一个字节）

### Q4: 如何验证发送成功？
- 查看"发送历史"页面
- 观察发送统计数字变化
- 使用Wireshark抓包验证
- 在目标设备查看接收日志

### Q5: 定时发送如何停止？
- 点击"停止定时发送"按钮
- 或关闭GUI程序
- 发送间隔可以随时调整

## 功能对比

| 功能 | 接收 | 发送 |
|------|------|------|
| 自定义帧头帧尾 | ✅ | ✅ |
| Hex数据 | ✅ | ✅ |
| 文本数据 | ✅ | ✅ |
| 历史记录 | ✅ | ✅ |
| 定时功能 | - | ✅ |
| 数据编辑 | - | ✅ |

## 注意事项

1. **网络连通性**：确保上位机与目标设备在同一网段或网络可达
2. **端口冲突**：发送端口可以与接收端口不同，避免冲突
3. **数据大小**：UDP单包最大约64KB，建议单包不超过1400字节
4. **定时精度**：定时发送的精度约为±50ms
5. **并发使用**：接收和发送功能可以同时使用

## 技术支持

如有问题或建议，请通过以下方式反馈：
- GitHub Issues
- 项目README.md中的联系方式

---

**最后更新**: 2025年11月16日  
**版本**: v3.0
